# coding:utf-8
from typing import Union, overload, List, Dict

from PySide6.QtWidgets import QWidget, QFrame
from PySide6.QtCore import Qt, QRect, Signal, QPropertyAnimation, QPoint, QTimer, QEvent
from PySide6.QtGui import QPainter, QColor, QFontMetrics, QPen, QWheelEvent

from ...common.color import themeColor, isDarkTheme
from ...common.font import setFont
from ...common.icon import FluentIcon, drawIcon, Icon
from ...components.navigation.navigation_panel import RouteKeyError
from ...components.widgets.tool_tip import setToolTipInfo
from ..layout import HBoxLayout
from ..widgets.scroll_widget import SingleDirectionScrollArea


class SlidingWidget(QWidget):
    clicked = Signal(QWidget)

    def __init__(self, text: str, icon: FluentIcon = None, isSelected=False):
        super().__init__()
        self.isHover = False
        self.isSelected = isSelected
        self.__text = text
        self.__icon = None
        self.__textColor = None
        self.__hoverColor = None
        self.__selectedColor = None
        self.__iconSize = 16
        self.__fontMetrics = QFontMetrics(self.__text)
        self._adjustSize()
        if icon:
            self.setIcon(icon)
        setFont(self, 16)

    def _adjustSize(self, size=0):
        self.setMinimumSize(self.__fontMetrics.horizontalAdvance(self.__text) + 32 + size, 35)

    def enterEvent(self, event):
        self.isHover = True
        self.__updateIconColor()
        self.update()
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.isHover = False
        self.__updateIconColor()
        self.update()
        super().leaveEvent(event)

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        self.clicked.emit(self)

    def setSelected(self, isSelected: bool):
        self.isSelected = isSelected
        self.__updateIconColor()
        self.update()

    def setText(self, text: str):
        self.__text = text
        self._adjustSize()
        self.update()

    def setIcon(self, icon: FluentIcon):
        self.__icon = icon
        self._adjustSize(self.__iconSize * 2)
        self.update()

    def setIconSize(self, size: int):
        if self.__iconSize == size:
            return
        self.__iconSize = size
        self.update()

    def setTextColor(self, color: Union[str, QColor]):
        if self.__textColor == color:
            return
        self.__textColor = color
        self.update()

    def setHoverTextColor(self, color: Union[str, QColor]):
        if self.__hoverColor == color:
            return
        self.__hoverColor = color
        self.update()

    def setSelectedColor(self, color: Union[str, QColor]):
        if self.__selectedColor == color:
            return
        self.__selectedColor = color
        self.update()
        self.__updateIconColor()

    def __updateIconColor(self):
        if self.__icon:
            tc = themeColor()
            if self.isSelected:
                c = self.__selectedColor or tc
                self.__icon = self.__icon.colored(c, c)
                return
            elif self.isHover:
                c = self.__hoverColor or tc
                self.__icon = self.__icon.colored(c, c)
                return
            c = 255 if isDarkTheme() else 0
            c = QColor(c, c, c)
            self.__icon = self.__icon.colored(c, c)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing | QPainter.TextAntialiasing | QPainter.SmoothPixmapTransform)
        rect = self.rect()
        align = Qt.AlignCenter
        if self.__icon:
            x = (self.width() - self.__fontMetrics.horizontalAdvance(self.__text) - self.__iconSize) / 2
            y = (self.height() - self.__iconSize) / 2
            drawIcon(Icon(self.__icon), painter, QRect(x, y, self.__iconSize, self.__iconSize))
            rect.adjust(x + self.__iconSize + 10, 0, 0, 0)
            align = Qt.AlignVCenter
        self._drawText(painter, rect, align)

    def _drawText(self, painter: QPainter, rect: QRect, align: Qt.AlignmentFlag):
        c = 255 if isDarkTheme() else 0
        if self.isSelected:
            painter.setPen(self.__selectedColor or themeColor())
        elif self.isHover:
            painter.setPen(self.__hoverColor or themeColor())
        else:
            painter.setPen(self.__textColor or QColor(c, c, c))
        painter.drawText(rect, align, self.__text)


class SlidingLine(QFrame):

    def __init__(self, parent=None, color: QColor = None, height=4):
        super().__init__(parent)
        self.setFixedHeight(height)
        self.hide()
        self.__color = color

    def setLineColor(self, color: QColor | str):
        self.__color = QColor(color)
        self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setPen(Qt.NoPen)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(self.__color or themeColor())
        painter.drawRoundedRect(self.rect(), 2, 2)


class SmoothSeparator(QWidget):
    """ Smooth Switch Separator """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedWidth(6)
        self.color = None

    def setSeparatorColor(self, color: str | QColor):
        self.color = QColor(color)
        self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        color = 255 if isDarkTheme() else 0
        pen = QPen(self.color or QColor(color, color, color, 128), 3)
        pen.setCapStyle(Qt.RoundCap)
        painter.setPen(pen)
        painter.drawLine(2, 10, 2, self.height() - 10)


class SlidingNavigationBar(SingleDirectionScrollArea):

    currentItemChange = Signal(SlidingWidget)

    def __init__(self, parent: QWidget):
        super().__init__(parent, Qt.Horizontal)
        self.setFixedHeight(60)
        self._items = {} # type: Dict[str, SlidingWidget]
        self.__widget = QWidget()
        self.__currentWidget = None # type: SlidingWidget
        self.__slideLineWidth = 30
        self.__slidingLine = SlidingLine(self.__widget)
        self.__slidingLine.raise_()
        self.__slidingLine.setFixedSize(self.__slideLineWidth, 3)
        self.__posAni = QPropertyAnimation(self.__slidingLine, b"pos")

        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.enableTransparentBackground()
        self.setWidgetResizable(True)
        self.setWidget(self.__widget)

        self._widgetLayout = HBoxLayout(self.__widget)
        self.currentItemChange.connect(lambda w:  w.update())
        parent.installEventFilter(self)

    def wheelEvent(self, e: QWheelEvent):
        super().wheelEvent(e)
        for _ in self._items.values():
            _.isHover = False
            _.update()

    def __getSlideEndPos(self, item: SlidingWidget):
        pos = item.pos()
        x = pos.x()
        y = pos.y()
        width = item.width()
        height = item.height()
        return QPoint(x + width / 2 - self.__slideLineWidth / 2, y + height + 5)

    def __createPosAni(self, item: SlidingWidget):
        self.__posAni.setDuration(200)
        self.__posAni.setStartValue(self.__slidingLine.pos())
        self.__posAni.setEndValue(self.__getSlideEndPos(item))
        self.__posAni.start()

    def __adjustSlideLinePos(self):
        QTimer.singleShot(1, lambda: (self.__slidingLine.move(self.__getSlideEndPos(self.__currentWidget))))

    def _onClicked(self, item: SlidingWidget):
        self.setCurrentWidget(item)

    def setBarAlignment(self, alignment: Qt.AlignmentFlag):
        self._widgetLayout.setAlignment(alignment)

    def addSeparator(self):
        return self.insertSeparator(-1)

    def insertSeparator(self, index: int):
        separator = SmoothSeparator(self)
        self._widgetLayout.insertWidget(index, separator)
        return separator

    def setSlideLineWidth(self, width: int):
        self.__slideLineWidth = width
        self.__slidingLine.setFixedWidth(self.__slideLineWidth)
        self.__adjustSlideLinePos()

    def setSlideLineColor(self, color: str | QColor):
        self.__slidingLine.setLineColor(color)

    def setItemSelectedColor(self, color: str | QColor):
        for item in self._items.values():
            item.setSelectedColor(color)

    def setItemColor(self, color: str | QColor):
        for item in self._items.values():
            item.setTextColor(color)

    def setItemHoverColor(self, color: str | QColor):
        for item in self._items.values():
            item.setHoverTextColor(color)

    def setItemSize(self, width: int, height: int):
        for item in self._items.values():
            item.setFixedSize(width, height)

    @overload
    def setCurrentWidget(self, item: str): ...
    @overload
    def setCurrentWidget(self, item: SlidingWidget): ...

    def setCurrentWidget(self, item: str | SlidingWidget):
        if self.__slidingLine.isHidden(): self.__slidingLine.show()
        if isinstance(item, str):
            if item not in self._items.keys():
                return
            item = self._items[item]
        if item not in self._items.values():
            return
        for _item_ in self._items.values():
            _item_.setSelected(False)
        if self.currentWidget():
            self.currentItemChange.emit(self.__currentWidget)
        self.__currentWidget = item
        item.setSelected(True)
        QTimer.singleShot(1, lambda: self.__createPosAni(item))

    def setCurrentIndex(self, index: int):
        self.setCurrentWidget(list(self._items.keys())[index])

    def addStretch(self, stretch: int):
        self._widgetLayout.addStretch(stretch)

    def addItem(
            self,
            routeKey: str,
            text: str,
            icon: FluentIcon = None,
            onClick=None,
            isSelected=False,
            alignment: Qt.AlignmentFlag = Qt.AlignTop,
            toolTip: str = None
    ):
        self.insertItem(-1, routeKey, text, icon, onClick, isSelected, alignment, toolTip)

    def insertItem(
            self,
            index: int,
            routeKey: str,
            text: str,
            icon: FluentIcon = None,
            onClick=None,
            isSelected=False,
            alignment: Qt.AlignmentFlag = Qt.AlignTop,
            toolTip: str = None
    ):
        if routeKey in self._items.keys():
            raise RouteKeyError('routeKey Are Not Unique')
        item = SlidingWidget(text, icon)
        item.setProperty("routeKey", routeKey)
        self._widgetLayout.insertWidget(index, item, alignment=alignment)
        self._items[routeKey] = item

        item.clicked.connect(lambda w: self._onClicked(w))
        item.clicked.connect(onClick)
        if isSelected:
            self.setCurrentWidget(routeKey)
        if toolTip:
            setToolTipInfo(item, toolTip, 1000)

    def currentWidget(self):
        return self.__currentWidget

    def item(self, routeKey: str) -> SlidingWidget:
        return self._items[routeKey]

    def allItem(self) -> List[SlidingWidget]:
        return list(self._items.values())

    def eventFilter(self, obj, event):
        if event.type() in [QEvent.Resize, QEvent.WindowStateChange] and self.currentWidget():
            self.__adjustSlideLinePos()
        return super().eventFilter(obj, event)


class SlidingToolNavigationBar(SlidingNavigationBar):

    def __init__(self, parent):
        super().__init__(parent)

    def setIconSize(self, size: int):
        for item in self.allWidget():
            item.setIconSize(size)

    def addItem(
            self,
            routeKey: str,
            icon: FluentIcon,
            onClick=None,
            isSelected=False,
            alignment: Qt.AlignmentFlag = Qt.AlignTop,
            toolTip: str = None
    ):
        self.insertItem(-1, routeKey, icon, onClick, isSelected, alignment, toolTip)

    def insertItem(
            self,
            index: int,
            routeKey: str,
            icon: FluentIcon,
            onClick=None,
            isSelected=False,
            alignment: Qt.AlignmentFlag = Qt.AlignTop,
            toolTip: str = None
    ):
        if routeKey in self._items.keys():
            raise RouteKeyError('routeKey Are Not Unique')
        item = SlidingWidget('', icon)
        item.setProperty("routeKey", routeKey)
        self._widgetLayout.insertWidget(index, item, alignment=alignment)
        self._items[routeKey] = item

        item.clicked.connect(lambda w: self._onClicked(w))
        if onClick:
            item.clicked.connect(onClick)
        if isSelected:
            self.setCurrentWidget(routeKey)
        if toolTip:
            setToolTipInfo(item, toolTip, 1000)